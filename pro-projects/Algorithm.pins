; Sun Jun 18 18:18:47 MSK 2017
; 
;+ (version "3.5")
;+ (build "Build 663")

([Algorithm_Class0] of  CloFunction

	(source "(mapcat #(if (symbol? %) [%] (destruct %)) lst)")
	(title "destruct [lst]"))

([Algorithm_Class1] of  CloFunction

	(source "(let [mp (into {} hm)]\n  (trace (is? (mp \"trace\")))\n  (future (do-algorithm inst [])))")
	(title "start-algorithm [hm inst]"))

([Algorithm_Class10000] of  CloProgram

	(cloFunctions
		[Algorithm_Class10003]
		[Algorithm_Class70005]
		[Algorithm_Class10006]
		[Algorithm_Class0]
		[Algorithm_Class20024]
		[Algorithm_Class70009]
		[Algorithm_Class40002]
		[Algorithm_Class40000]
		[Algorithm_Class20001]
		[Algorithm_Class30000]
		[Algorithm_Class50001]
		[Algorithm_Class10002]
		[Algorithm_Class40004]
		[Algorithm_Class20013]
		[Algorithm_Class70000]
		[Algorithm_Class50000]
		[Algorithm_Class90005]
		[Algorithm_Class20011]
		[Algorithm_Class1])
	(cloNamespace [Algorithm_Class10001])
	(cloVars
		[Algorithm_Class20023]
		[Algorithm_Class40001]
		[Algorithm_Class30001])
	(title "Algorithm Execution"))

([Algorithm_Class10001] of  CloNamespace

	(source "(:use protege.core)\n(:require\n  [rete.core :as rete])\n(:import\n  edu.stanford.smi.protege.model.Instance)")
	(title "algo.exe"))

([Algorithm_Class10002] of  CloFunction

	(source "(do-trace proc bnd)\n(do-next (sv proc \"next\") (do-code proc bnd))")
	(title "do-process [proc bnd]"))

([Algorithm_Class10003] of  CloFunction

	(source "(rete.core/slurp-with-comments (java.io.StringReader. src))")
	(title "uncomment [src]"))

([Algorithm_Class10006] of  CloFunction

	(source "(if (= (count obs) 1)\n  (ob-to-code (first obs))\n  (vec (map ob-to-code obs)))")
	(title "trans-obs [obs]"))

([Algorithm_Class20001] of  CloFunction

	(source "(do-trace inp bnd)\n(do-next \n  (sv inp \"next\")\n  (let [code (sv inp \"code\")\n          vprs (map #(list (symbol (first %)) (second %))\n	(partition 2 (read-string (str \"[\" (uncomment  code) \"]\"))))\n          oprs (map #(list (symbol (sv % \"variable\")) (trans-obs (svs % \"objects\")))\n	(svs inp \"object-rows\"))\n          uprs (filter #(not (some #{(first %)} bnd))\n	(concat vprs oprs))\n          ubnd (apply concat uprs)]\n    (concat bnd ubnd)))")
	(title "do-input [inp bnd]"))

([Algorithm_Class20011] of  CloFunction

	(source "(if (some? inst)\n  (condp = (typ inst)\n    \"Process\" (do-process inst bnd)\n    \"Decision\" (do-decision inst bnd)\n    \"PredefinedProcess\" (do-preproc inst bnd)\n    \"Input\" (do-input inst bnd)\n    \"Concurrent\" (do-concurrent inst bnd)\n    \"Wait\" bnd\n    (println (str \"Unknown type: \" typ)))\n  bnd)")
	(title "do-next [inst bnd]"))

([Algorithm_Class20013] of  CloFunction

	(source "(do-trace dec bnd)\n(let [bnd2 (do-code dec bnd)]\n  (do-variant (last bnd2) \n	(vec (svs dec \"variants\")) \n	(vec (butlast (butlast bnd2)))))")
	(title "do-decision [dec bnd]"))

([Algorithm_Class20023] of  CloVar

	(source "nil")
	(title "do-next"))

([Algorithm_Class20024] of  CloFunction

	(source "(let [p2 (partition 2 bnd)\n      vars (destruct (map first p2))\n      nams (map name vars)]\n  (zipmap nams vars))")
	(title "var-val-map [bnd]"))

([Algorithm_Class30000] of  CloFunction

	(source "(vec (reduce-kv #(if (not= %2 \"_\")\n	      (concat %1 [(symbol %2) (val-to-code %3)])\n	      %1) [] vvm))")
	(title "to-bnd [vvm]"))

([Algorithm_Class30001] of  CloVar

	(source "nil")
	(title "destruct"))

([Algorithm_Class40000] of  CloFunction

	(source "(when TRACE\n  (println :binding bnd)\n  (println (typ inst) (sv inst \"title\")))")
	(title "do-trace [inst bnd]"))

([Algorithm_Class40001] of  CloVar

	(source "nil")
	(title "TRACE"))

([Algorithm_Class40002] of  CloFunction

	(source "(def TRACE bool)")
	(title "trace [bool]"))

([Algorithm_Class40004] of  CloFunction

	(source "(if (<= 1 vrt (count vrts))\n  (do-next (nth vrts (dec vrt)) bnd))")
	(title "do-variant [vrt vrts bnd]"))

([Algorithm_Class50000] of  CloFunction

	(source "(do-trace prep bnd)\n(do-next (sv prep \"next\") (do-algorithm (sv prep \"algorithm\") bnd))")
	(title "do-preproc [prep bnd]"))

([Algorithm_Class50001] of  CloFunction

	(source "(let [code (sv pord \"code\")\n       bnd2 (read-string (str \"[\" (uncomment  code) \"]\"))\n       bnd3 (vec (concat bnd bnd2))\n       vvm1 (var-val-map bnd3)\n       expr `(let ~bnd3 ~vvm1)\n       ;;_ (println :expr expr)\n       vvm2  (try (eval expr) (catch Exception e (println e)))]\n  ;;(println :vvm2 vvm2)\n  (to-bnd vvm2))")
	(title "do-code [pord bnd]"))

([Algorithm_Class70000] of  CloFunction

	(source "(do-trace algo bnd)\n(do-next (sv algo \"begin\") bnd)")
	(title "do-algorithm [algo bnd]"))

([Algorithm_Class70005] of  CloFunction

	(source "`(.getInstance *kb*  ~(.getName ob))")
	(title "ob-to-code [ob]"))

([Algorithm_Class70009] of  CloFunction

	(source "(cond\n  (vector? val) (vec (map val-to-code val))\n  (seq? val) (map val-to-code val)\n  (instance? Instance val) (ob-to-code val)\n  true val)")
	(title "val-to-code [val]"))

([Algorithm_Class90005] of  CloFunction

	(source "(do-trace conc bnd)\n(do-next (sv (sv conc \"wait\") \"next\")\n              (mapcat #(deref %) \n	    (loop [curs (svs conc \"currents\") futs []]\n	      (if (seq curs)\n	        (recur (rest curs) (conj futs (future (do-next (first curs) bnd))))\n	        futs))))")
	(title "do-concurrent [conc bnd]"))
